schema {
  query: Query
  mutation: Mutation
}

type AdvertiserProfile {
  companyName: String
  industry: String
  website: String
  campaigns("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: CampaignFilterInput @cost(weight: "10") order: [CampaignSortInput!] @cost(weight: "10")): CampaignsConnection @authorize @listSize(assumedSize: 50, slicingArguments: [ "first", "last" ], slicingArgumentDefaultValue: 10, sizedFields: [ "edges", "nodes" ], requireOneSlicingArgument: false) @cost(weight: "10")
  userId: UUID!
  user: User!
  onboardingComplete: Boolean!
  stripeAccountId: String
  stripeAccountStatus: String
  stripeLastAccountHealthCheck: DateTime
  stripeAccountDisconnectedAt: DateTime
  stripeAccountDisconnectedNotifiedAt: DateTime
  id: UUID!
  createdAt: DateTime!
}

type Campaign {
  advertiserProfileId: UUID!
  advertiserProfile: AdvertiserProfile!
  name: String!
  description: String
  imageUrl: String!
  targetAudience: String
  goals: String
  totalBudget: Decimal
  status: CampaignStatus!
  startDate: DateTime
  endDate: DateTime
  id: UUID!
  createdAt: DateTime!
}

"A connection to a list of items."
type CampaignsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [CampaignsEdge!]
  "A flattened list of the nodes."
  nodes: [Campaign!]
}

"An edge in a connection."
type CampaignsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Campaign!
}

type CreateSpacePayload {
  space: Space
}

type DeleteSpacePayload {
  space: Space
}

type Mutation {
  createSpace(input: CreateSpaceInput!): CreateSpacePayload! @cost(weight: "10")
  deleteSpace(input: DeleteSpaceInput!): DeleteSpacePayload! @cost(weight: "10")
  updateCurrentUser(input: UpdateCurrentUserInput!): UpdateCurrentUserPayload! @cost(weight: "10")
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type Query {
  spaceById(id: ID!): Space @authorize @cost(weight: "10")
  spaces("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: SpaceFilterInput @cost(weight: "10") order: [SpaceSortInput!] @cost(weight: "10")): SpacesConnection @listSize(assumedSize: 50, slicingArguments: [ "first", "last" ], slicingArgumentDefaultValue: 10, sizedFields: [ "edges", "nodes" ], requireOneSlicingArgument: false) @cost(weight: "10")
  currentUser: User @authorize @cost(weight: "10")
  userById(id: ID!): User @authorize(roles: [ "Admin" ]) @cost(weight: "10")
  users("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: UserFilterInput @cost(weight: "10") order: [UserSortInput!] @cost(weight: "10")): UsersConnection @authorize(roles: [ "Admin" ]) @listSize(assumedSize: 50, slicingArguments: [ "first", "last" ], slicingArgumentDefaultValue: 10, sizedFields: [ "edges", "nodes" ], requireOneSlicingArgument: false) @cost(weight: "10")
}

type Space {
  spaceOwnerProfileId: UUID!
  spaceOwnerProfile: SpaceOwnerProfile!
  title: String!
  description: String
  type: SpaceType!
  status: SpaceStatus!
  address: String!
  city: String!
  state: String!
  zipCode: String
  latitude: Float!
  longitude: Float!
  width: Float
  height: Float
  dimensions: String
  dimensionsText: String
  pricePerDay: Decimal!
  installationFee: Decimal
  minDuration: Int!
  maxDuration: Int
  images: [String!]!
  availableFrom: DateTime
  availableTo: DateTime
  totalBookings: Int!
  totalRevenue: Decimal!
  averageRating: Float
  rejectionReason: String
  traffic: String
  id: UUID!
  createdAt: DateTime!
}

type SpaceOwnerProfile {
  businessName: String
  businessType: String
  payoutSchedule: PayoutSchedule!
  spaces("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: SpaceFilterInput @cost(weight: "10") order: [SpaceSortInput!] @cost(weight: "10")): SpacesConnection @authorize @listSize(assumedSize: 50, slicingArguments: [ "first", "last" ], slicingArgumentDefaultValue: 10, sizedFields: [ "edges", "nodes" ], requireOneSlicingArgument: false) @cost(weight: "10")
  userId: UUID!
  user: User!
  onboardingComplete: Boolean!
  stripeAccountId: String
  stripeAccountStatus: String
  stripeLastAccountHealthCheck: DateTime
  stripeAccountDisconnectedAt: DateTime
  stripeAccountDisconnectedNotifiedAt: DateTime
  id: UUID!
  createdAt: DateTime!
}

"A connection to a list of items."
type SpacesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [SpacesEdge!]
  "A flattened list of the nodes."
  nodes: [Space!]
}

"An edge in a connection."
type SpacesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Space!
}

type UpdateCurrentUserPayload {
  user: User
}

type User {
  email: String!
  password: String!
  name: String!
  phone: String
  avatar: String
  role: UserRole!
  status: UserStatus!
  activeProfileType: ProfileType!
  lastLoginAt: DateTime
  advertiserProfile: AdvertiserProfile @authorize @cost(weight: "10")
  spaceOwnerProfile: SpaceOwnerProfile @authorize @cost(weight: "10")
  id: UUID!
  createdAt: DateTime!
}

"A connection to a list of items."
type UsersConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [UsersEdge!]
  "A flattened list of the nodes."
  nodes: [User!]
}

"An edge in a connection."
type UsersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User!
}

input AdvertiserProfileFilterInput {
  and: [AdvertiserProfileFilterInput!]
  or: [AdvertiserProfileFilterInput!]
  companyName: StringOperationFilterInput
  industry: StringOperationFilterInput
  website: StringOperationFilterInput
  campaigns: ListFilterInputTypeOfCampaignFilterInput
  userId: UuidOperationFilterInput
  user: UserFilterInput
  onboardingComplete: BooleanOperationFilterInput
  stripeAccountId: StringOperationFilterInput
  stripeAccountStatus: StringOperationFilterInput
  stripeLastAccountHealthCheck: DateTimeOperationFilterInput
  stripeAccountDisconnectedAt: DateTimeOperationFilterInput
  stripeAccountDisconnectedNotifiedAt: DateTimeOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
}

input AdvertiserProfileInput {
  companyName: String
  industry: String
  website: String
  campaigns: [CampaignInput!]!
  userId: UUID!
  user: UserInput!
  onboardingComplete: Boolean!
  stripeAccountId: String
  stripeAccountStatus: String
  stripeLastAccountHealthCheck: DateTime
  stripeAccountDisconnectedAt: DateTime
  stripeAccountDisconnectedNotifiedAt: DateTime
  id: UUID!
  createdAt: DateTime!
}

input AdvertiserProfileSortInput {
  companyName: SortEnumType @cost(weight: "10")
  industry: SortEnumType @cost(weight: "10")
  website: SortEnumType @cost(weight: "10")
  userId: SortEnumType @cost(weight: "10")
  user: UserSortInput @cost(weight: "10")
  onboardingComplete: SortEnumType @cost(weight: "10")
  stripeAccountId: SortEnumType @cost(weight: "10")
  stripeAccountStatus: SortEnumType @cost(weight: "10")
  stripeLastAccountHealthCheck: SortEnumType @cost(weight: "10")
  stripeAccountDisconnectedAt: SortEnumType @cost(weight: "10")
  stripeAccountDisconnectedNotifiedAt: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
}

input BooleanOperationFilterInput {
  eq: Boolean @cost(weight: "10")
  neq: Boolean @cost(weight: "10")
}

input CampaignFilterInput {
  and: [CampaignFilterInput!]
  or: [CampaignFilterInput!]
  advertiserProfileId: UuidOperationFilterInput
  advertiserProfile: AdvertiserProfileFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  imageUrl: StringOperationFilterInput
  targetAudience: StringOperationFilterInput
  goals: StringOperationFilterInput
  totalBudget: DecimalOperationFilterInput
  status: CampaignStatusOperationFilterInput
  startDate: DateTimeOperationFilterInput
  endDate: DateTimeOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
}

input CampaignInput {
  advertiserProfileId: UUID!
  advertiserProfile: AdvertiserProfileInput!
  name: String!
  description: String
  imageUrl: String!
  targetAudience: String
  goals: String
  totalBudget: Decimal
  status: CampaignStatus!
  startDate: DateTime
  endDate: DateTime
  id: UUID!
  createdAt: DateTime!
}

input CampaignSortInput {
  advertiserProfileId: SortEnumType @cost(weight: "10")
  advertiserProfile: AdvertiserProfileSortInput @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  imageUrl: SortEnumType @cost(weight: "10")
  targetAudience: SortEnumType @cost(weight: "10")
  goals: SortEnumType @cost(weight: "10")
  totalBudget: SortEnumType @cost(weight: "10")
  status: SortEnumType @cost(weight: "10")
  startDate: SortEnumType @cost(weight: "10")
  endDate: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
}

input CampaignStatusOperationFilterInput {
  eq: CampaignStatus @cost(weight: "10")
  neq: CampaignStatus @cost(weight: "10")
  in: [CampaignStatus!] @cost(weight: "10")
  nin: [CampaignStatus!] @cost(weight: "10")
}

input CreateSpaceInput {
  title: String!
  description: String
  type: SpaceType!
  address: String!
  city: String!
  state: String!
  zipCode: String
  latitude: Float!
  longitude: Float!
  width: Float
  height: Float
  dimensions: String
  pricePerDay: Decimal!
  installationFee: Decimal
  minDuration: Int!
  maxDuration: Int
  images: [String!]
  availableFrom: DateTime
  availableTo: DateTime
  dimensionsText: String
  traffic: String
}

input DateTimeOperationFilterInput {
  eq: DateTime @cost(weight: "10")
  neq: DateTime @cost(weight: "10")
  in: [DateTime] @cost(weight: "10")
  nin: [DateTime] @cost(weight: "10")
  gt: DateTime @cost(weight: "10")
  ngt: DateTime @cost(weight: "10")
  gte: DateTime @cost(weight: "10")
  ngte: DateTime @cost(weight: "10")
  lt: DateTime @cost(weight: "10")
  nlt: DateTime @cost(weight: "10")
  lte: DateTime @cost(weight: "10")
  nlte: DateTime @cost(weight: "10")
}

input DecimalOperationFilterInput {
  eq: Decimal @cost(weight: "10")
  neq: Decimal @cost(weight: "10")
  in: [Decimal] @cost(weight: "10")
  nin: [Decimal] @cost(weight: "10")
  gt: Decimal @cost(weight: "10")
  ngt: Decimal @cost(weight: "10")
  gte: Decimal @cost(weight: "10")
  ngte: Decimal @cost(weight: "10")
  lt: Decimal @cost(weight: "10")
  nlt: Decimal @cost(weight: "10")
  lte: Decimal @cost(weight: "10")
  nlte: Decimal @cost(weight: "10")
}

input DeleteSpaceInput {
  id: ID!
}

input FloatOperationFilterInput {
  eq: Float @cost(weight: "10")
  neq: Float @cost(weight: "10")
  in: [Float] @cost(weight: "10")
  nin: [Float] @cost(weight: "10")
  gt: Float @cost(weight: "10")
  ngt: Float @cost(weight: "10")
  gte: Float @cost(weight: "10")
  ngte: Float @cost(weight: "10")
  lt: Float @cost(weight: "10")
  nlt: Float @cost(weight: "10")
  lte: Float @cost(weight: "10")
  nlte: Float @cost(weight: "10")
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input ListFilterInputTypeOfCampaignFilterInput {
  all: CampaignFilterInput @cost(weight: "10")
  none: CampaignFilterInput @cost(weight: "10")
  some: CampaignFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfSpaceFilterInput {
  all: SpaceFilterInput @cost(weight: "10")
  none: SpaceFilterInput @cost(weight: "10")
  some: SpaceFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput @cost(weight: "10")
  none: StringOperationFilterInput @cost(weight: "10")
  some: StringOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input PayoutScheduleOperationFilterInput {
  eq: PayoutSchedule @cost(weight: "10")
  neq: PayoutSchedule @cost(weight: "10")
  in: [PayoutSchedule!] @cost(weight: "10")
  nin: [PayoutSchedule!] @cost(weight: "10")
}

input ProfileTypeOperationFilterInput {
  eq: ProfileType @cost(weight: "10")
  neq: ProfileType @cost(weight: "10")
  in: [ProfileType!] @cost(weight: "10")
  nin: [ProfileType!] @cost(weight: "10")
}

input SpaceFilterInput {
  and: [SpaceFilterInput!]
  or: [SpaceFilterInput!]
  spaceOwnerProfileId: UuidOperationFilterInput
  spaceOwnerProfile: SpaceOwnerProfileFilterInput
  title: StringOperationFilterInput
  description: StringOperationFilterInput
  type: SpaceTypeOperationFilterInput
  status: SpaceStatusOperationFilterInput
  address: StringOperationFilterInput
  city: StringOperationFilterInput
  state: StringOperationFilterInput
  zipCode: StringOperationFilterInput
  latitude: FloatOperationFilterInput
  longitude: FloatOperationFilterInput
  width: FloatOperationFilterInput
  height: FloatOperationFilterInput
  dimensions: StringOperationFilterInput
  dimensionsText: StringOperationFilterInput
  pricePerDay: DecimalOperationFilterInput
  installationFee: DecimalOperationFilterInput
  minDuration: IntOperationFilterInput
  maxDuration: IntOperationFilterInput
  images: ListStringOperationFilterInput
  availableFrom: DateTimeOperationFilterInput
  availableTo: DateTimeOperationFilterInput
  totalBookings: IntOperationFilterInput
  totalRevenue: DecimalOperationFilterInput
  averageRating: FloatOperationFilterInput
  rejectionReason: StringOperationFilterInput
  traffic: StringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
}

input SpaceInput {
  spaceOwnerProfileId: UUID!
  spaceOwnerProfile: SpaceOwnerProfileInput!
  title: String!
  description: String
  type: SpaceType!
  status: SpaceStatus!
  address: String!
  city: String!
  state: String!
  zipCode: String
  latitude: Float!
  longitude: Float!
  width: Float
  height: Float
  dimensions: String
  dimensionsText: String
  pricePerDay: Decimal!
  installationFee: Decimal
  minDuration: Int!
  maxDuration: Int
  images: [String!]!
  availableFrom: DateTime
  availableTo: DateTime
  totalBookings: Int!
  totalRevenue: Decimal!
  averageRating: Float
  rejectionReason: String
  traffic: String
  id: UUID!
  createdAt: DateTime!
}

input SpaceOwnerProfileFilterInput {
  and: [SpaceOwnerProfileFilterInput!]
  or: [SpaceOwnerProfileFilterInput!]
  businessName: StringOperationFilterInput
  businessType: StringOperationFilterInput
  payoutSchedule: PayoutScheduleOperationFilterInput
  spaces: ListFilterInputTypeOfSpaceFilterInput
  userId: UuidOperationFilterInput
  user: UserFilterInput
  onboardingComplete: BooleanOperationFilterInput
  stripeAccountId: StringOperationFilterInput
  stripeAccountStatus: StringOperationFilterInput
  stripeLastAccountHealthCheck: DateTimeOperationFilterInput
  stripeAccountDisconnectedAt: DateTimeOperationFilterInput
  stripeAccountDisconnectedNotifiedAt: DateTimeOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
}

input SpaceOwnerProfileInput {
  businessName: String
  businessType: String
  payoutSchedule: PayoutSchedule!
  spaces: [SpaceInput!]!
  userId: UUID!
  user: UserInput!
  onboardingComplete: Boolean!
  stripeAccountId: String
  stripeAccountStatus: String
  stripeLastAccountHealthCheck: DateTime
  stripeAccountDisconnectedAt: DateTime
  stripeAccountDisconnectedNotifiedAt: DateTime
  id: UUID!
  createdAt: DateTime!
}

input SpaceOwnerProfileSortInput {
  businessName: SortEnumType @cost(weight: "10")
  businessType: SortEnumType @cost(weight: "10")
  payoutSchedule: SortEnumType @cost(weight: "10")
  userId: SortEnumType @cost(weight: "10")
  user: UserSortInput @cost(weight: "10")
  onboardingComplete: SortEnumType @cost(weight: "10")
  stripeAccountId: SortEnumType @cost(weight: "10")
  stripeAccountStatus: SortEnumType @cost(weight: "10")
  stripeLastAccountHealthCheck: SortEnumType @cost(weight: "10")
  stripeAccountDisconnectedAt: SortEnumType @cost(weight: "10")
  stripeAccountDisconnectedNotifiedAt: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
}

input SpaceSortInput {
  spaceOwnerProfileId: SortEnumType @cost(weight: "10")
  spaceOwnerProfile: SpaceOwnerProfileSortInput @cost(weight: "10")
  title: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  type: SortEnumType @cost(weight: "10")
  status: SortEnumType @cost(weight: "10")
  address: SortEnumType @cost(weight: "10")
  city: SortEnumType @cost(weight: "10")
  state: SortEnumType @cost(weight: "10")
  zipCode: SortEnumType @cost(weight: "10")
  latitude: SortEnumType @cost(weight: "10")
  longitude: SortEnumType @cost(weight: "10")
  width: SortEnumType @cost(weight: "10")
  height: SortEnumType @cost(weight: "10")
  dimensions: SortEnumType @cost(weight: "10")
  dimensionsText: SortEnumType @cost(weight: "10")
  pricePerDay: SortEnumType @cost(weight: "10")
  installationFee: SortEnumType @cost(weight: "10")
  minDuration: SortEnumType @cost(weight: "10")
  maxDuration: SortEnumType @cost(weight: "10")
  availableFrom: SortEnumType @cost(weight: "10")
  availableTo: SortEnumType @cost(weight: "10")
  totalBookings: SortEnumType @cost(weight: "10")
  totalRevenue: SortEnumType @cost(weight: "10")
  averageRating: SortEnumType @cost(weight: "10")
  rejectionReason: SortEnumType @cost(weight: "10")
  traffic: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
}

input SpaceStatusOperationFilterInput {
  eq: SpaceStatus @cost(weight: "10")
  neq: SpaceStatus @cost(weight: "10")
  in: [SpaceStatus!] @cost(weight: "10")
  nin: [SpaceStatus!] @cost(weight: "10")
}

input SpaceTypeOperationFilterInput {
  eq: SpaceType @cost(weight: "10")
  neq: SpaceType @cost(weight: "10")
  in: [SpaceType!] @cost(weight: "10")
  nin: [SpaceType!] @cost(weight: "10")
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

input UpdateCurrentUserInput {
  updatedUser: UserInput!
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  email: StringOperationFilterInput
  password: StringOperationFilterInput
  name: StringOperationFilterInput
  phone: StringOperationFilterInput
  avatar: StringOperationFilterInput
  role: UserRoleOperationFilterInput
  status: UserStatusOperationFilterInput
  activeProfileType: ProfileTypeOperationFilterInput
  lastLoginAt: DateTimeOperationFilterInput
  advertiserProfile: AdvertiserProfileFilterInput
  spaceOwnerProfile: SpaceOwnerProfileFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
}

input UserInput {
  email: String!
  password: String!
  name: String!
  phone: String
  avatar: String
  role: UserRole!
  status: UserStatus!
  activeProfileType: ProfileType!
  lastLoginAt: DateTime
  advertiserProfile: AdvertiserProfileInput
  spaceOwnerProfile: SpaceOwnerProfileInput
  id: UUID!
  createdAt: DateTime!
}

input UserRoleOperationFilterInput {
  eq: UserRole @cost(weight: "10")
  neq: UserRole @cost(weight: "10")
  in: [UserRole!] @cost(weight: "10")
  nin: [UserRole!] @cost(weight: "10")
}

input UserSortInput {
  email: SortEnumType @cost(weight: "10")
  password: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  phone: SortEnumType @cost(weight: "10")
  avatar: SortEnumType @cost(weight: "10")
  role: SortEnumType @cost(weight: "10")
  status: SortEnumType @cost(weight: "10")
  activeProfileType: SortEnumType @cost(weight: "10")
  lastLoginAt: SortEnumType @cost(weight: "10")
  advertiserProfile: AdvertiserProfileSortInput @cost(weight: "10")
  spaceOwnerProfile: SpaceOwnerProfileSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
}

input UserStatusOperationFilterInput {
  eq: UserStatus @cost(weight: "10")
  neq: UserStatus @cost(weight: "10")
  in: [UserStatus!] @cost(weight: "10")
  nin: [UserStatus!] @cost(weight: "10")
}

input UuidOperationFilterInput {
  eq: UUID @cost(weight: "10")
  neq: UUID @cost(weight: "10")
  in: [UUID] @cost(weight: "10")
  nin: [UUID] @cost(weight: "10")
  gt: UUID @cost(weight: "10")
  ngt: UUID @cost(weight: "10")
  gte: UUID @cost(weight: "10")
  ngte: UUID @cost(weight: "10")
  lt: UUID @cost(weight: "10")
  nlt: UUID @cost(weight: "10")
  lte: UUID @cost(weight: "10")
  nlte: UUID @cost(weight: "10")
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum CampaignStatus {
  DRAFT
  SUBMITTED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum PayoutSchedule {
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum ProfileType {
  ADVERTISER
  SPACE_OWNER
}

enum SortEnumType {
  ASC
  DESC
}

enum SpaceStatus {
  ACTIVE
  INACTIVE
  PENDING_APPROVAL
  SUSPENDED
  REJECTED
}

enum SpaceType {
  BILLBOARD
  STOREFRONT
  TRANSIT
  DIGITAL_DISPLAY
  WINDOW_DISPLAY
  VEHICLE_WRAP
  OTHER
}

enum UserRole {
  USER
  ADMIN
  MARKETING
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

"The authorize directive."
directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on OBJECT | FIELD_DEFINITION

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize("The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field." assumedSize: Int "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments." slicingArguments: [String!] "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query." slicingArgumentDefaultValue: Int "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields." sizedFields: [String!] "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error." requireOneSlicingArgument: Boolean! = true) on FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")