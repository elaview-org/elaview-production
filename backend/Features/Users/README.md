# Users Feature Implementation Guide

Complete implementation specifications for the Users feature GraphQL operations.

---

## File Structure

```
Features/Users/
├── README.md                 # This file
├── UserQueries.cs            # Query resolvers (me, userById, users)
├── UserMutations.cs          # Mutation resolvers
├── UserService.cs            # IUserService + UserService
├── UserRepository.cs         # IUserRepository + UserRepository
├── UserInputs.cs             # Input record types
├── UserExtensions.cs         # User type extensions
├── AdvertiserExtensions.cs   # AdvertiserProfile type extensions
└── SpaceOwnerExtensions.cs   # SpaceOwnerProfile type extensions
```

---

## Queries

### `me` - [NOT IMPLEMENTED]

Returns the authenticated user's profile. Entry point for all user-scoped data via extensions.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Name | `[GraphQLName("me")]` |
| Middleware | `[UseFirstOrDefault]` → `[UseProjection]` |
| Return Type | `IQueryable<User>` |

**Resolver:**
```
Method: Me(IUserService userService)
Delegates to: userService.GetCurrentUser()
```

**Service Layer:**
```
IUserService.GetCurrentUser() → IQueryable<User>
  - Calls GetPrincipalId() to extract user ID from ClaimTypes.NameIdentifier
  - Returns repository.GetById(principalId)
```

**Repository Layer:**
```
IUserRepository.GetById(Guid id) → IQueryable<User>
  - Returns context.Users.Where(u => u.Id == id).OrderBy(u => u.Id)
  - OrderBy required to suppress EF warning with [UseFirstOrDefault]
```

**DB Query Optimization:**
- Base query: 1 DB call
- With nested profiles via `[BindMember]`: Still 1 DB call (projection handles JOINs)
- With nested paginated collections: +1 DB call per collection

**GraphQL Usage:**
```graphql
query {
  me {
    id
    email
    name
    activeProfileType
    advertiserProfile { companyName }
    spaceOwnerProfile { businessName }
  }
}
```

---

### `userById` - [NOT IMPLEMENTED]

Admin-only query to fetch any user by ID.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize(Roles = ["Admin"])]` |
| Middleware | `[UseFirstOrDefault]` → `[UseProjection]` |
| Parameters | `[ID] Guid id` |
| Return Type | `IQueryable<User>` |

**Resolver:**
```
Method: UserById([ID] Guid id, IUserService userService)
Delegates to: userService.GetById(id)
```

**Service Layer:**
```
IUserService.GetById(Guid id) → IQueryable<User>
  - Returns repository.GetById(id)
  - No authorization check (admin-only via [Authorize])
```

**Repository Layer:**
```
IUserRepository.GetById(Guid id) → IQueryable<User>
  - Same as me query
```

---

### `users` - [NOT IMPLEMENTED]

Admin-only paginated list of all users with filtering and sorting.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize(Roles = ["Admin"])]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<User>` |

**Resolver:**
```
Method: Users(IUserService userService)
Delegates to: userService.GetAll()
```

**Service Layer:**
```
IUserService.GetAll() → IQueryable<User>
  - Returns repository.Query()
  - No default ordering (client controls via order argument)
```

**Repository Layer:**
```
IUserRepository.Query() → IQueryable<User>
  - Returns context.Users (unfiltered)
```

**Supported Filters (auto-generated by HotChocolate):**
| Field | Operations |
|-------|------------|
| `email` | eq, neq, contains, startsWith, endsWith |
| `name` | eq, neq, contains, startsWith, endsWith |
| `role` | eq, neq, in, nin |
| `status` | eq, neq, in, nin |
| `createdAt` | eq, neq, gt, gte, lt, lte |
| `lastLoginAt` | eq, neq, gt, gte, lt, lte |

**GraphQL Usage:**
```graphql
query {
  users(
    first: 20
    where: { status: { eq: ACTIVE }, role: { eq: USER } }
    order: { createdAt: DESC }
  ) {
    nodes { id email name }
    pageInfo { hasNextPage endCursor }
    totalCount
  }
}
```

---

## Mutations

### `updateMe` - [NOT IMPLEMENTED]

Update the authenticated user's basic info.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Errors | `[Error<ValidationException>]` |
| Parameters | `UpdateUserInput input` |
| Return Type | `Task<User>` |

**Resolver:**
```
Method: UpdateMe(UpdateUserInput input, IUserService userService, CancellationToken ct)
Delegates to: userService.UpdateAsync(input, ct)
```

**Input Type:**
```csharp
public record UpdateUserInput(
    string? Name,      // MaxLength: 255
    string? Phone,     // Format: E.164 (+1234567890)
    string? Avatar     // URL, MaxLength: 500
);
```

**Service Layer:**
```
IUserService.UpdateAsync(UpdateUserInput input, CancellationToken ct) → Task<User>
  1. Get principalId via GetPrincipalId()
  2. Fetch user via repository.GetByIdAsync(principalId, ct) [DataLoader]
  3. Validate input fields (throw ValidationException if invalid)
  4. Apply non-null fields to entity
  5. Save via repository.UpdateAsync(user, ct)
  6. Return updated user
```

**Validation Rules:**
- `Name`: 1-255 characters if provided
- `Phone`: E.164 format if provided
- `Avatar`: Valid URL, max 500 characters if provided

---

### `switchProfileType` - [NOT IMPLEMENTED]

Switch active profile between Advertiser and SpaceOwner.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Errors | `[Error<ForbiddenException>]` |
| Parameters | `ProfileType type` |
| Return Type | `Task<User>` |

**Resolver:**
```
Method: SwitchProfileType(ProfileType type, IUserService userService, CancellationToken ct)
Delegates to: userService.SwitchProfileTypeAsync(type, ct)
```

**Service Layer:**
```
IUserService.SwitchProfileTypeAsync(ProfileType type, CancellationToken ct) → Task<User>
  1. Fetch current user with profiles via DataLoader
  2. Check if target profile exists and onboarding is complete
     - If not: throw ForbiddenException("complete onboarding for this profile type first")
  3. Update user.ActiveProfileType = type
  4. Save and return
```

**Business Rules:**
- Cannot switch to profile that doesn't exist
- Cannot switch to profile with `OnboardingComplete = false`

---

### `updateAdvertiserProfile` - [NOT IMPLEMENTED]

Update advertiser profile details.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Errors | `[Error<NotFoundException>]`, `[Error<ValidationException>]` |
| Parameters | `UpdateAdvertiserProfileInput input` |
| Return Type | `Task<AdvertiserProfile>` |

**Resolver:**
```
Method: UpdateAdvertiserProfile(UpdateAdvertiserProfileInput input, IUserService userService, CancellationToken ct)
Delegates to: userService.UpdateAdvertiserProfileAsync(input, ct)
```

**Input Type:**
```csharp
public record UpdateAdvertiserProfileInput(
    string? CompanyName,  // MaxLength: 255
    string? Industry,     // MaxLength: 255
    string? Website       // URL, MaxLength: 500
);
```

**Service Layer:**
```
IUserService.UpdateAdvertiserProfileAsync(input, ct) → Task<AdvertiserProfile>
  1. Get principalId
  2. Fetch profile via repository.GetAdvertiserProfileByUserIdAsync(principalId, ct)
  3. If null: throw NotFoundException("AdvertiserProfile", principalId)
  4. Validate and apply non-null fields
  5. Save and return
```

---

### `updateSpaceOwnerProfile` - [NOT IMPLEMENTED]

Update space owner profile details.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Errors | `[Error<NotFoundException>]`, `[Error<ValidationException>]` |
| Parameters | `UpdateSpaceOwnerProfileInput input` |
| Return Type | `Task<SpaceOwnerProfile>` |

**Resolver:**
```
Method: UpdateSpaceOwnerProfile(UpdateSpaceOwnerProfileInput input, IUserService userService, CancellationToken ct)
Delegates to: userService.UpdateSpaceOwnerProfileAsync(input, ct)
```

**Input Type:**
```csharp
public record UpdateSpaceOwnerProfileInput(
    string? BusinessName,           // MaxLength: 255
    string? BusinessType,           // MaxLength: 255
    PayoutSchedule? PayoutSchedule  // Enum: Daily, Weekly, Monthly
);
```

**Service Layer:**
```
IUserService.UpdateSpaceOwnerProfileAsync(input, ct) → Task<SpaceOwnerProfile>
  1. Get principalId
  2. Fetch profile via repository.GetSpaceOwnerProfileByUserIdAsync(principalId, ct)
  3. If null: throw NotFoundException("SpaceOwnerProfile", principalId)
  4. Validate and apply non-null fields
  5. Save and return
```

---

### `completeOnboarding` - [NOT IMPLEMENTED]

Mark onboarding complete for a profile type, creating profile if needed.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Errors | `[Error<ValidationException>]` |
| Parameters | `ProfileType profileType` |
| Return Type | `Task<User>` |

**Resolver:**
```
Method: CompleteOnboarding(ProfileType profileType, IUserService userService, CancellationToken ct)
Delegates to: userService.CompleteOnboardingAsync(profileType, ct)
```

**Service Layer:**
```
IUserService.CompleteOnboardingAsync(ProfileType profileType, ct) → Task<User>
  1. Fetch current user
  2. Check if profile exists for profileType
  3. If not exists:
     - Create new profile with OnboardingComplete = true
     - Associate with user
  4. If exists:
     - Set profile.OnboardingComplete = true
  5. Set user.ActiveProfileType = profileType
  6. Save all changes
  7. Return user
```

**Side Effects:**
- Creates AdvertiserProfile or SpaceOwnerProfile if missing
- Updates user's active profile type

---

### `deleteUser` - [NOT IMPLEMENTED]

Admin-only soft delete of user.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize(Roles = ["Admin"])]` |
| Errors | `[Error<NotFoundException>]`, `[Error<ConflictException>]` |
| Parameters | `[ID] Guid id` |
| Return Type | `Task<bool>` |

**Resolver:**
```
Method: DeleteUser([ID] Guid id, IUserService userService, CancellationToken ct)
Delegates to: userService.DeleteAsync(id, ct)
```

**Service Layer:**
```
IUserService.DeleteAsync(Guid id, ct) → Task<bool>
  1. Fetch user via DataLoader
  2. If null: throw NotFoundException("User", id)
  3. Check for active bookings (optional: throw ConflictException if found)
  4. Set user.Status = UserStatus.Deleted
  5. Save and return true
```

**Business Rules:**
- Soft delete only (sets status, doesn't remove data)
- Consider checking for active bookings before allowing delete

---

## Type Extensions

### UserExtensions

Extensions on the `User` type for accessing related data.

#### `advertiserProfile` - [NOT IMPLEMENTED]

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Binding | `[BindMember(nameof(User.AdvertiserProfile))]` |
| Return Type | `AdvertiserProfile?` |

**Resolver:**
```
Method: GetAdvertiserProfile([Parent] User user)
Returns: user.AdvertiserProfile
```

**Query Optimization:**
- `[BindMember]` tells HotChocolate this resolves the navigation property
- Parent query's `[UseProjection]` handles the JOIN
- Result: 0 additional DB queries

---

#### `spaceOwnerProfile` - [NOT IMPLEMENTED]

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Binding | `[BindMember(nameof(User.SpaceOwnerProfile))]` |
| Return Type | `SpaceOwnerProfile?` |

**Resolver:**
```
Method: GetSpaceOwnerProfile([Parent] User user)
Returns: user.SpaceOwnerProfile
```

---

#### `notifications` - [NOT IMPLEMENTED]

User's notifications (replaces top-level `myNotifications`).

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Notification>` |

**Resolver:**
```
Method: GetNotifications([Parent] User user, INotificationService service)
Delegates to: service.GetByUserId(user.Id)
```

**Service Layer:**
```
INotificationService.GetByUserId(Guid userId) → IQueryable<Notification>
  - Returns context.Notifications
      .Where(n => n.UserId == userId)
      .OrderByDescending(n => n.CreatedAt)
```

**Supported Filters:**
| Field | Operations |
|-------|------------|
| `type` | eq, in |
| `isRead` | eq |
| `createdAt` | gt, gte, lt, lte |
| `entityType` | eq |

**GraphQL Usage:**
```graphql
query {
  me {
    notifications(first: 10, where: { isRead: { eq: false } }) {
      nodes { id type title body createdAt }
    }
  }
}
```

---

#### `unreadNotificationCount` - [NOT IMPLEMENTED]

Count of unread notifications.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Return Type | `Task<int>` |

**Resolver:**
```
Method: GetUnreadNotificationCount([Parent] User user, INotificationService service, CancellationToken ct)
Delegates to: service.GetUnreadCountAsync(user.Id, ct)
```

**Service Layer:**
```
INotificationService.GetUnreadCountAsync(Guid userId, ct) → Task<int>
  - Returns context.Notifications
      .Where(n => n.UserId == userId && !n.IsRead)
      .CountAsync(ct)
```

---

#### `notificationPreferences` - [NOT IMPLEMENTED]

User's notification channel preferences.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UseProjection]` |
| Return Type | `IQueryable<NotificationPreference>` |

**Resolver:**
```
Method: GetNotificationPreferences([Parent] User user, INotificationPreferenceService service)
Delegates to: service.GetByUserId(user.Id)
```

**Note:** No pagination needed (fixed set of notification types).

---

#### `conversations` - [NOT IMPLEMENTED]

User's message conversations.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseSorting]` |
| Return Type | `IQueryable<Conversation>` |

**Resolver:**
```
Method: GetConversations([Parent] User user, IMessagingService service)
Delegates to: service.GetConversationsByUserId(user.Id)
```

**Service Layer:**
```
IMessagingService.GetConversationsByUserId(Guid userId) → IQueryable<Conversation>
  - Returns context.Conversations
      .Where(c => c.Participants.Any(p => p.UserId == userId))
      .OrderByDescending(c => c.UpdatedAt)
```

---

#### `unreadMessageCount` - [NOT IMPLEMENTED]

Total unread messages across all conversations.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Return Type | `Task<int>` |

**Resolver:**
```
Method: GetUnreadMessageCount([Parent] User user, IMessagingService service, CancellationToken ct)
Delegates to: service.GetUnreadCountAsync(user.Id, ct)
```

---

#### `reviews` - [NOT IMPLEMENTED]

Reviews written by this user.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseSorting]` |
| Return Type | `IQueryable<Review>` |

**Resolver:**
```
Method: GetReviews([Parent] User user, IReviewService service)
Delegates to: service.GetByReviewerId(user.Id)
```

---

### AdvertiserExtensions

Extensions on `AdvertiserProfile` type.

#### `campaigns` - [NOT IMPLEMENTED]

Campaigns owned by this advertiser.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Campaign>` |

**Resolver:**
```
Method: GetCampaigns([Parent] AdvertiserProfile advertiser, ICampaignService service)
Delegates to: service.GetByAdvertiserId(advertiser.Id)
```

**Service Layer:**
```
ICampaignService.GetByAdvertiserId(Guid advertiserId) → IQueryable<Campaign>
  - Returns context.Campaigns
      .Where(c => c.AdvertiserProfileId == advertiserId)
      .OrderByDescending(c => c.CreatedAt)
```

---

#### `bookings` - [NOT IMPLEMENTED]

Bookings made by this advertiser (via their campaigns).

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Booking>` |

**Resolver:**
```
Method: GetBookings([Parent] AdvertiserProfile advertiser, IBookingService service)
Delegates to: service.GetByAdvertiserProfileId(advertiser.Id)
```

**Service Layer:**
```
IBookingService.GetByAdvertiserProfileId(Guid advertiserId) → IQueryable<Booking>
  - Returns context.Bookings
      .Where(b => b.Campaign.AdvertiserProfileId == advertiserId)
      .OrderByDescending(b => b.CreatedAt)
```

**GraphQL Usage:**
```graphql
query {
  me {
    advertiserProfile {
      bookings(first: 10, where: { status: { in: [PAID, VERIFIED] } }) {
        nodes { id status totalAmount space { title } }
      }
    }
  }
}
```

---

### SpaceOwnerExtensions

Extensions on `SpaceOwnerProfile` type.

#### `spaces` - [NOT IMPLEMENTED]

Spaces owned by this space owner.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Space>` |

**Resolver:**
```
Method: GetSpaces([Parent] SpaceOwnerProfile owner, ISpaceService service)
Delegates to: service.GetByOwnerId(owner.Id)
```

**Service Layer:**
```
ISpaceService.GetByOwnerId(Guid ownerId) → IQueryable<Space>
  - Returns context.Spaces
      .Where(s => s.SpaceOwnerProfileId == ownerId)
      .OrderByDescending(s => s.CreatedAt)
```

---

#### `bookings` - [NOT IMPLEMENTED]

Bookings on spaces owned by this owner.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Booking>` |

**Resolver:**
```
Method: GetBookings([Parent] SpaceOwnerProfile owner, IBookingService service)
Delegates to: service.GetBySpaceOwnerProfileId(owner.Id)
```

**Service Layer:**
```
IBookingService.GetBySpaceOwnerProfileId(Guid ownerId) → IQueryable<Booking>
  - Returns context.Bookings
      .Where(b => b.Space.SpaceOwnerProfileId == ownerId)
      .OrderByDescending(b => b.CreatedAt)
```

---

#### `payouts` - [NOT IMPLEMENTED]

Payouts received by this owner.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Middleware | `[UsePaging]` → `[UseProjection]` → `[UseFiltering]` → `[UseSorting]` |
| Return Type | `IQueryable<Payout>` |

**Resolver:**
```
Method: GetPayouts([Parent] SpaceOwnerProfile owner, IPayoutService service)
Delegates to: service.GetByOwnerProfileId(owner.Id)
```

**Service Layer:**
```
IPayoutService.GetByOwnerProfileId(Guid ownerId) → IQueryable<Payout>
  - Returns context.Payouts
      .Where(p => p.SpaceOwnerProfileId == ownerId)
      .OrderByDescending(p => p.CreatedAt)
```

---

#### `earningsSummary` - [NOT IMPLEMENTED]

Aggregated earnings data.

| Attribute | Value |
|-----------|-------|
| Auth | `[Authorize]` |
| Return Type | `Task<EarningsSummary>` |

**Resolver:**
```
Method: GetEarningsSummary([Parent] SpaceOwnerProfile owner, IPayoutService service, CancellationToken ct)
Delegates to: service.GetEarningsSummaryAsync(owner.Id, ct)
```

**Return Type (DTO):**
```csharp
public record EarningsSummary(
    decimal TotalEarnings,      // Sum of completed payouts (all time)
    decimal PendingPayouts,     // Sum of pending/processing payouts
    decimal AvailableBalance,   // Available for withdrawal
    decimal ThisMonthEarnings,  // Completed this month
    decimal LastMonthEarnings   // Completed last month
);
```

**Service Layer:**
```
IPayoutService.GetEarningsSummaryAsync(Guid ownerId, ct) → Task<EarningsSummary>
  - Performs aggregation query on Payouts table
  - Groups by status and date ranges
  - Returns computed EarningsSummary
```

---

## DataLoader Requirements

| DataLoader | Key Type | Returns | Used By |
|------------|----------|---------|---------|
| `UserById` | `Guid` | `User?` | Mutations (fetch to update) |
| `AdvertiserProfileByUserId` | `Guid` | `AdvertiserProfile?` | Mutations on profile |
| `SpaceOwnerProfileByUserId` | `Guid` | `SpaceOwnerProfile?` | Mutations on profile |

**Pattern:** DataLoaders used only for mutations (fetching entity to modify). Extensions use `IQueryable` for projection optimization.

---

## DB Query Count Summary

| Query Pattern | DB Queries | Notes |
|---------------|------------|-------|
| `me { id email name }` | 1 | Projection |
| `me { advertiserProfile { id } }` | 1 | BindMember + projection |
| `me { spaceOwnerProfile { id } }` | 1 | BindMember + projection |
| `me { advertiserProfile { campaigns { nodes { id } } } }` | 2 | Pagination = separate query |
| `me { spaceOwnerProfile { spaces { nodes { id } } } }` | 2 | Pagination = separate query |
| `me { notifications { nodes { id } } }` | 2 | Pagination = separate query |
| `me { unreadNotificationCount }` | 2 | Scalar = separate query |

---

## Implementation Checklist

### Queries
- [ ] `me`
- [ ] `userById`
- [ ] `users`

### Mutations
- [ ] `updateMe`
- [ ] `switchProfileType`
- [ ] `updateAdvertiserProfile`
- [ ] `updateSpaceOwnerProfile`
- [ ] `completeOnboarding`
- [ ] `deleteUser`

### User Extensions
- [ ] `advertiserProfile`
- [ ] `spaceOwnerProfile`
- [ ] `notifications`
- [ ] `unreadNotificationCount`
- [ ] `notificationPreferences`
- [ ] `conversations`
- [ ] `unreadMessageCount`
- [ ] `reviews`

### AdvertiserProfile Extensions
- [ ] `campaigns`
- [ ] `bookings`

### SpaceOwnerProfile Extensions
- [ ] `spaces`
- [ ] `bookings`
- [ ] `payouts`
- [ ] `earningsSummary`

---

**Last Updated:** 2026-01-16